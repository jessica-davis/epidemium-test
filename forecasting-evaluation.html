<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epidemic Forecasting and Evaluation — Epidemium</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Lato:wght@300;400;700&family=Patrick+Hand&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/roughjs@4.6.6/bundled/rough.js"></script>
    <style>
/* ============================================================
   STYLES
   ============================================================ */

/* --- Base / Reset --- */
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Lato', sans-serif;
    background-color: #ffffff;
    color: #1C2442;
    line-height: 1.6;
}

/* --- Layout --- */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    font-family: 'Montserrat', sans-serif;
    font-size: 2rem;
    font-weight: 700;
    color: #1C2442;
    margin-bottom: 5px;
}

.subtitle {
    font-size: 1rem;
    color: #2F4474;
    margin-bottom: 20px;
}

.back-link {
    display: inline-block;
    font-family: 'Lato', sans-serif;
    font-size: 0.9rem;
    font-weight: 600;
    color: #1E9CC5;
    text-decoration: none;
    margin-bottom: 16px;
}

.back-link:hover { text-decoration: underline; }

.loading {
    text-align: center;
    padding: 40px;
    font-size: 1.1rem;
    color: #1E9CC5;
}

.error {
    background-color: #fee;
    border-left: 4px solid #c00;
    padding: 15px 20px;
    margin: 20px 0;
    border-radius: 4px;
    color: #c00;
}

/* --- Sidebar Navigation --- */
.app-layout {
    display: flex;
    gap: 0;
}

.sidebar {
    width: 280px;
    flex-shrink: 0;
    border-right: 1px solid #e0e0e0;
    padding: 8px 0;
    transition: width 0.25s ease, opacity 0.25s ease;
    overflow: hidden;
    position: sticky;
    top: 0;
    align-self: flex-start;
    max-height: 100vh;
    overflow-y: auto;
}

.sidebar.collapsed {
    width: 0;
    border-right: none;
    padding: 0;
}

.sidebar.collapsed .sidebar-inner {
    opacity: 0;
    pointer-events: none;
}

.sidebar-inner {
    width: 280px;
    transition: opacity 0.2s ease;
}

.sidebar-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    background: none;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    padding: 5px 12px;
    font-family: 'Lato', sans-serif;
    font-size: 0.8rem;
    font-weight: 600;
    color: #2F4474;
    cursor: pointer;
    margin-bottom: 12px;
    transition: all 0.2s;
}

.sidebar-toggle:hover {
    border-color: #1E9CC5;
    color: #1E9CC5;
}

.sidebar-toggle .arrow {
    display: inline-block;
    transition: transform 0.2s;
}

.sidebar-toggle.closed .arrow {
    transform: rotate(180deg);
}

.sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 16px 12px;
    border-bottom: 1px solid #eee;
    margin-bottom: 8px;
}

.sidebar-title {
    font-family: 'Montserrat', sans-serif;
    font-size: 0.95rem;
    font-weight: 700;
    color: #1C2442;
}

.main-content {
    flex: 1;
    min-width: 0;
    padding-left: 24px;
    transition: padding-left 0.25s ease;
}

.sidebar.collapsed + .main-content {
    padding-left: 0;
}

.nav-outline {
    list-style: none;
    padding: 0 16px;
}

.nav-outline ul {
    list-style: none;
    padding-left: 16px;
}

.nav-heading {
    display: block;
    font-family: 'Montserrat', sans-serif;
    font-size: 0.78rem;
    font-weight: 700;
    color: #1C2442;
    padding: 14px 8px 4px;
}

.nav-subheading {
    display: block;
    font-family: 'Lato', sans-serif;
    font-size: 0.76rem;
    font-weight: 600;
    color: #2F4474;
    padding: 8px 8px 2px;
}

.nav-item {
    display: block;
    padding: 6px 12px;
    font-size: 0.84rem;
    color: #2F4474;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.15s;
    text-decoration: none;
    border-left: 3px solid transparent;
}

a.nav-item:hover {
    color: #1E9CC5;
    background: #f8f8f8;
}

.nav-item.active {
    color: #1C2442;
    font-weight: 600;
    border-left-color: #1E9CC5;
    background: #f0f8ff;
}

.nav-item.disabled {
    color: #bbb;
    cursor: default;
    font-size: 0.8rem;
}

.badge-soon {
    display: inline-block;
    font-size: 0.58rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    background: #f0f0f0;
    color: #aaa;
    padding: 1px 5px;
    border-radius: 3px;
    margin-left: 4px;
    vertical-align: middle;
}

.mobile-menu-btn {
    display: none;
    background: none;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px 10px;
    font-size: 1.2rem;
    cursor: pointer;
    color: #1C2442;
    line-height: 1;
    margin-bottom: 10px;
}

/* --- Content Sections --- */
.content-section {
    display: none;
}

.content-section.active {
    display: block;
}

.content-wrapper {
    display: grid;
    grid-template-columns: 1fr 320px;
    gap: 30px;
    align-items: start;
}

.chart-section { width: 100%; }

.description-section {
    padding: 20px;
    background-color: #F2F2F2;
    border-radius: 8px;
}

.description-section h3 {
    font-family: 'Montserrat', sans-serif;
    font-size: 1.2rem;
    font-weight: 600;
    color: #344D84;
    margin-bottom: 12px;
}

.description-section p {
    margin-bottom: 12px;
    line-height: 1.7;
    font-size: 0.9rem;
}

.description-section .definition {
    font-style: italic;
    color: #2F4474;
    margin-bottom: 25px;
    padding-left: 15px;
    border-left: 3px solid #1E9CC5;
}

.description-section .example {
    background-color: white;
    padding: 20px;
    border-radius: 6px;
    margin-top: 20px;
}

.description-section .example strong {
    color: #344D84;
    display: block;
    margin-bottom: 10px;
}

.section-heading {
    font-family: 'Montserrat', sans-serif;
    font-size: 1.5rem;
    font-weight: 700;
    color: #1C2442;
    margin-bottom: 5px;
}

.section-sub {
    font-size: 0.95rem;
    color: #2F4474;
    margin-bottom: 20px;
}

.section-divider {
    border: none;
    border-top: 1px dashed #ddd;
    margin: 30px 0;
}

.info-box {
    background-color: #DFF8ED;
    border-left: 4px solid #1E9CC5;
    padding: 15px 20px;
    margin: 20px 0;
    border-radius: 4px;
}

.info-box p { margin: 5px 0; }

/* --- Overview Section --- */
.overview-intro {
    max-width: 800px;
    font-size: 1.05rem;
    line-height: 1.8;
    margin-bottom: 30px;
}

.overview-intro p {
    margin-bottom: 16px;
}

.overview-outline {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-top: 20px;
}

.outline-card {
    background: #f8f8f8;
    border-radius: 8px;
    padding: 24px;
    border-left: 4px solid #1E9CC5;
}

.outline-card h3 {
    font-family: 'Montserrat', sans-serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: #1C2442;
    margin-bottom: 8px;
}

.outline-card p {
    font-size: 0.9rem;
    color: #2F4474;
    margin-bottom: 12px;
}

.outline-card ul {
    list-style: none;
    padding: 0;
}

.outline-card li {
    padding: 4px 0;
    font-size: 0.88rem;
}

.outline-card a {
    color: #1E9CC5;
    text-decoration: none;
    font-weight: 600;
    cursor: pointer;
}

.outline-card a:hover { text-decoration: underline; }

.outline-card .coming-soon-text {
    color: #bbb;
    font-style: italic;
}

/* --- Charts --- */
.chart-container {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.chart-title {
    font-family: 'Montserrat', sans-serif;
    font-size: 1.1rem;
    font-weight: 600;
    color: #1C2442;
    margin-bottom: 10px;
}

.axis-label {
    font-size: 14px;
    font-weight: 600;
    fill: #1C2442;
    font-family: 'Patrick Hand', cursive;
}

.tick-label {
    font-family: 'Patrick Hand', cursive;
    font-size: 12px;
    fill: #1C2442;
}

.legend-text {
    font-family: 'Patrick Hand', cursive;
    font-size: 13px;
    fill: #1C2442;
}

/* --- Controls --- */
.controls {
    margin-bottom: 15px;
    padding: 12px 16px;
    background-color: #F2F2F2;
    border-radius: 6px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    align-items: center;
}

.controls label {
    font-weight: 600;
    color: #1C2442;
    margin-right: 10px;
}

.control-group {
    display: flex;
    gap: 10px;
    align-items: center;
}

.toggle-btn {
    padding: 8px 16px;
    border: 2px solid #344D84;
    background-color: white;
    color: #344D84;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Lato', sans-serif;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s;
}

.toggle-btn.active {
    background-color: #344D84;
    color: white;
}

.toggle-btn:hover {
    background-color: #1E9CC5;
    border-color: #1E9CC5;
    color: white;
}

/* --- Boxplot --- */
.boxplot-container {
    background-color: #ffffff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.boxplot-controls {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 10px;
    padding: 10px 14px;
    background-color: #F2F2F2;
    border-radius: 6px;
}

.wis-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 180px;
    height: 6px;
    border-radius: 3px;
    background: #ddd;
    outline: none;
}

.wis-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #344D84;
    cursor: pointer;
}

.width-label {
    font-family: 'Patrick Hand', cursive;
    font-size: 0.9rem;
    color: #344D84;
}

.coverage-row {
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Patrick Hand', cursive;
    font-size: 0.95rem;
    margin: 4px 0;
}

.coverage-check { font-size: 1.1rem; }
.coverage-hit { color: #27ae60; }
.coverage-miss { color: #c0392b; }

.drag-hint {
    font-size: 0.8rem;
    color: #999;
    font-style: italic;
    margin-top: 6px;
}

/* --- WIS Scores --- */
.wis-component {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 6px 0;
    font-size: 0.85rem;
}

.wis-component .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    flex-shrink: 0;
}

.wis-scores { margin-top: 15px; }

.wis-score-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    padding: 8px 0;
    border-bottom: 1px solid #e0e0e0;
}

.wis-score-row:last-child { border-bottom: none; }

.wis-score-label {
    font-size: 0.85rem;
    color: #1C2442;
}

.wis-score-value {
    font-family: 'Patrick Hand', cursive;
    font-size: 1.2rem;
    font-weight: 600;
}

.rwis-highlight {
    background: white;
    border-radius: 6px;
    padding: 12px;
    margin-top: 12px;
    text-align: center;
}

.rwis-label { font-size: 0.85rem; color: #2F4474; }

.rwis-value {
    font-family: 'Patrick Hand', cursive;
    font-size: 2rem;
    font-weight: 700;
}

.rwis-good { color: #27ae60; }
.rwis-bad { color: #c0392b; }

.rwis-interp {
    font-size: 0.8rem;
    color: #666;
    margin-top: 4px;
}

#wis-decomp { margin-top: 12px; }

/* --- Math Section --- */
.math-details {
    margin: 30px 0;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
}

.math-details summary {
    padding: 14px 20px;
    font-family: 'Montserrat', sans-serif;
    font-weight: 600;
    font-size: 1rem;
    color: #344D84;
    cursor: pointer;
    background: #F2F2F2;
    list-style: none;
}

.math-details summary::-webkit-details-marker { display: none; }
.math-details summary::before { content: '+ '; font-weight: 700; }
.math-details[open] summary::before { content: '- '; }

.math-body {
    padding: 20px 24px;
    font-size: 0.9rem;
    line-height: 1.8;
}

.math-body ul {
    margin: 8px 0 8px 20px;
}

.math-body li {
    margin: 4px 0;
}

.math-eq {
    font-family: 'Patrick Hand', cursive;
    font-size: 1.1rem;
    background: #f8f8f8;
    padding: 12px 16px;
    border-radius: 6px;
    margin: 12px 0;
    border-left: 3px solid #1E9CC5;
    overflow-x: auto;
}

.math-label {
    font-weight: 600;
    color: #344D84;
    margin-top: 16px;
    display: block;
}

.citation {
    margin-top: 20px;
    padding: 12px 16px;
    background: #f8f8f8;
    border-radius: 6px;
    font-size: 0.85rem;
    color: #555;
}

.citation a { color: #1E9CC5; }

/* --- Responsive --- */
@media (max-width: 900px) {
    .content-wrapper {
        grid-template-columns: 1fr;
    }
    .overview-outline {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 600px) {
    .mobile-menu-btn { display: block; }
    .sidebar-toggle { display: none; }

    .app-layout { flex-direction: column; }

    .sidebar {
        position: fixed;
        top: 0; left: 0; bottom: 0;
        z-index: 100;
        background: #fff;
        box-shadow: 2px 0 12px rgba(0,0,0,0.1);
        width: 0;
    }
    .sidebar.open {
        width: 280px;
        padding: 16px 0;
    }
    .sidebar.open .sidebar-inner {
        width: 280px;
        opacity: 1;
        pointer-events: auto;
    }

    h1 { font-size: 1.4rem; }
    .subtitle { font-size: 0.85rem; }
    .section-heading { font-size: 1.2rem; }

    .controls, .boxplot-controls {
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
    }

    .description-section { padding: 14px; }
    .chart-container { padding: 12px; }
}
    </style>
</head>
<body>
<!-- ============================================================
     HTML
     ============================================================ -->

    <div class="container">
        <a href="index.html" class="back-link">&larr; Epidemium</a>
        <h1>Epidemic Forecasting and Evaluation</h1>
        <p class="subtitle">Understanding forecast outputs, scoring rules, and model comparison</p>

        <div id="loading" class="loading">Loading data...</div>
        <div id="error" class="error" style="display:none;"></div>

        <div id="main-app" style="display:none;">

        <!-- Mobile hamburger -->
        <button class="mobile-menu-btn" id="mobile-menu-btn">&#9776; Contents</button>

        <div class="app-layout">
            <!-- Sidebar navigation -->
            <nav class="sidebar" id="sidebar">
              <div class="sidebar-inner">
                <div class="sidebar-header">
                    <span class="sidebar-title">Contents</span>
                </div>
                <ul class="nav-outline">
                    <li><a class="nav-item active" data-section="section-overview">Overview</a></li>
                    <li>
                        <span class="nav-heading">1. Forecast Outputs</span>
                        <ul>
                            <li><a class="nav-item" data-section="section-pi">a. Prediction Intervals</a></li>
                            <li><a class="nav-item" data-section="section-trends">b. Categorical Forecasts</a></li>
                        </ul>
                    </li>
                    <li>
                        <span class="nav-heading">2. Evaluation Metrics</span>
                        <ul>
                            <li>
                                <span class="nav-subheading">a. Interval-based scoring</span>
                                <ul>
                                    <li><a class="nav-item" data-section="section-wis">i. Weighted Interval Score</a></li>
                                    <li><span class="nav-item disabled">ii. Coverage <span class="badge-soon">Soon</span></span></li>
                                </ul>
                            </li>
                            <li>
                                <span class="nav-subheading">b. Categorical scoring</span>
                                <ul>
                                    <li><span class="nav-item disabled">i. Brier Score <span class="badge-soon">Soon</span></span></li>
                                    <li><span class="nav-item disabled">ii. Ranked Probability Score <span class="badge-soon">Soon</span></span></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
              </div>
            </nav>

            <!-- Main content area -->
            <div class="main-content">
            <button class="sidebar-toggle" id="sidebar-toggle">
                <span class="arrow">&#9664;</span> <span class="label">Contents</span>
            </button>

            <!-- ==================== Overview ==================== -->
            <section id="section-overview" class="content-section active">
                <div class="overview-intro">
                    <p>Epidemic forecasts provide valuable situational awareness for public health decision-making. This was underscored during the COVID-19 pandemic, when decision-makers needed real-time information on the current and near-term trajectory of the outbreak. But epidemic forecasting predates COVID-19 — the CDC has run seasonal influenza forecasting challenges since [year], bringing together research teams to predict flu activity each season. While the specific targets and scoring methods have evolved over time, the core goal remains the same: generating accurate, timely predictions to inform public health response.</p>

                    <p>In this module, we define common types of epidemic forecast formats and introduce some methods used to evaluate them.</p>

                </div>

                <div class="overview-outline">
                    <div class="outline-card">
                        <h3>1. Epidemic Forecast Outputs</h3>
                        <p>What types of predictions do epidemic forecasters produce?</p>
                        <ul>
                            <li><a data-section="section-pi">Prediction Intervals</a> &mdash; Ranges where we expect future values to fall</li>
                            <li><a data-section="section-trends">Categorical Forecasts</a> &mdash; Trends, activity levels, and other categorical predictions</li>
                        </ul>
                    </div>
                    <div class="outline-card">
                        <h3>2. Evaluation Metrics</h3>
                        <p>How do we measure whether a forecast is any good?</p>
                        <ul>
                            <li><a data-section="section-wis">Weighted Interval Score</a> &mdash; Scoring prediction intervals</li>
                            <li><span class="coming-soon-text">Coverage, Brier Score, RPS &mdash; Coming soon</span></li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- ==================== Prediction Intervals ==================== -->
            <section id="section-pi" class="content-section">
                <div class="content-wrapper">
                    <div class="chart-section">
                        <div class="chart-container">
                            <h3 class="chart-title">Weekly Incident Flu Hospitalizations &mdash; US National</h3>
                            <div class="controls">
                                <div class="control-group">
                                    <label>Prediction Intervals:</label>
                                    <button class="toggle-btn active" data-interval="95">95%</button>
                                    <button class="toggle-btn active" data-interval="80">80%</button>
                                    <button class="toggle-btn active" data-interval="50">50%</button>
                                </div>
                            </div>
                            <div id="chart"></div>
                        </div>
                    </div>
                    <div class="description-section">
                        <h3>What are Prediction Intervals?</h3>
                        <p class="definition">
                            Prediction intervals quantify uncertainty in forecasts. They provide a range where we expect future observations to fall with a specified probability.
                        </p>
                        <div class="example">
                            <strong>Example: What does an 80% Prediction Interval mean?</strong>
                            <p>If we generate 100 forecasts with 80% prediction intervals, we expect approximately 80 of the observed values to fall within their respective intervals. The remaining 20 observations would fall outside.</p>
                            <p style="margin-top: 15px;">In other words, an 80% PI tells us: "We are 80% confident that the true future value will fall somewhere between the lower and upper bounds of this interval."</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== Categorical Forecasts ==================== -->
            <section id="section-trends" class="content-section">
                <h2 class="section-heading" style="margin-bottom:5px;">Categorical Forecasts</h2>
                <p class="section-sub">Rather than predicting a specific value or interval, it can be just as useful to predict a <em>category</em>. For example, is disease activity high or low? Do we expect it to increase, decrease, or stay the same over the coming weeks?</p>

                <div class="gauge-row" style="display:flex; gap:40px; justify-content:center; flex-wrap:wrap; margin:24px 0;">
                    <div class="gauge-panel" style="text-align:center; flex:1; min-width:260px; max-width:400px;">
                        <h3 class="chart-title" style="margin-bottom:4px;">Rate Trend</h3>
                        <p style="font-size:0.82rem; color:#666; margin-bottom:8px;">Direction of change</p>
                        <div id="trend-gauge"></div>
                    </div>
                    <div class="gauge-panel" style="text-align:center; flex:1; min-width:260px; max-width:400px;">
                        <h3 class="chart-title" style="margin-bottom:4px;">Activity Level</h3>
                        <p style="font-size:0.82rem; color:#666; margin-bottom:8px;">Intensity of disease burden</p>
                        <div id="activity-gauge"></div>
                    </div>
                </div>

                <div style="display:flex; gap:30px; flex-wrap:wrap; margin:20px 0;">
                    <div style="flex:1; min-width:280px;">
                        <h3 class="chart-title">Rate Trend Forecast</h3>
                        <div id="trend-chart"></div>
                    </div>
                    <div style="flex:1; min-width:280px;">
                        <h3 class="chart-title">Activity Level Forecast</h3>
                        <div id="activity-chart"></div>
                    </div>
                </div>

                <div class="example" style="margin-top:24px; max-width:800px; background:#f8f8f8; padding:20px; border-radius:6px;">
                    <strong style="color:#344D84; display:block; margin-bottom:10px;">Why use categorical forecasts?</strong>
                    <p style="font-size:0.9rem; line-height:1.7;">During periods of rapid epidemic change, exact count predictions are often unreliable. Categorical forecasts provide actionable information &mdash; "cases are likely increasing" &mdash; even when precise numbers are uncertain. They are evaluated using proper scoring rules like the <strong>Brier Score</strong> (for binary categories) or the <strong>Ranked Probability Score</strong> (for ordered categories like trend levels).</p>
                </div>
                    <div class="citation" style="margin-top:16px;">
                        Biggerstaff M, et al. (2024). Responding to the return of influenza in the United States. <em>JMIR Public Health and Surveillance</em> 10: e54340. <a href="https://doi.org/10.2196/54340" target="_blank" rel="noopener">doi:10.2196/54340</a>
                    </div>
                    <div class="citation" style="margin-top:8px;">
                        CDC (2025). Framework for classifying disease trends applied to influenza-associated hospital admissions. <em>Open Forum Infectious Diseases</em> 12(8): ofaf460. <a href="https://doi.org/10.1093/ofid/ofaf460" target="_blank" rel="noopener">doi:10.1093/ofid/ofaf460</a>
                    </div>
            </section>

            <!-- ==================== Weighted Interval Score ==================== -->
            <section id="section-wis" class="content-section">

                <!-- Section 1: Evaluating Quantile Forecasts -->
                <h2 class="section-heading" style="margin-bottom:5px;">Evaluating Quantile Forecasts</h2>
                <p class="section-sub">How do we measure whether a probabilistic forecast is any good?</p>

                <div class="content-wrapper" style="margin-bottom:10px;">
                    <div class="chart-section">
                        <div class="chart-container">
                            <h3 class="chart-title">Forecast as Prediction Intervals</h3>
                            <div class="controls">
                                <div class="control-group">
                                    <label>Show PIs:</label>
                                    <button class="toggle-btn active" data-wis-box-interval="95">95%</button>
                                    <button class="toggle-btn active" data-wis-box-interval="80">80%</button>
                                    <button class="toggle-btn active" data-wis-box-interval="50">50%</button>
                                </div>
                            </div>
                            <div id="wis-box-chart"></div>
                        </div>
                    </div>
                    <div class="description-section">
                        <h3>Sharpness vs. Calibration</h3>
                        <p>Quantile forecasts express uncertainty as prediction intervals. But how do we judge their quality? Two key properties:</p>
                        <p><strong>Sharpness</strong> &mdash; Are the intervals narrow? A forecast that says "between 0 and 100,000" is uninformative. Narrower intervals are more useful.</p>
                        <p><strong>Calibration</strong> &mdash; Do the observed values actually land inside the intervals at the right rate? An 80% PI should contain the observation about 80% of the time.</p>
                        <p class="definition" style="margin-top:15px;">The ideal forecast is as sharp as possible while remaining well-calibrated. We need a scoring rule that rewards both properties.</p>
                    </div>
                </div>

                <hr class="section-divider">

                <!-- Section 2: The WIS Score -->
                <h2 class="section-heading" style="margin-bottom:5px;">The Weighted Interval Score</h2>
                <p class="section-sub">Explore how interval width and observed values affect the score.</p>

                <div class="content-wrapper" style="margin-bottom:10px;">
                    <div class="chart-section">
                        <div class="boxplot-container">
                            <h3 class="chart-title">Explore: Single Forecast Date</h3>
                            <div class="boxplot-controls">
                                <div class="control-group">
                                    <label>Show PIs:</label>
                                    <button class="toggle-btn active" data-bp-interval="95">95%</button>
                                    <button class="toggle-btn active" data-bp-interval="80">80%</button>
                                    <button class="toggle-btn active" data-bp-interval="50">50%</button>
                                </div>
                                <div class="control-group">
                                    <label>Width:</label>
                                    <span class="width-label">Sharp</span>
                                    <input type="range" class="wis-slider" id="bp-width-slider" min="0.3" max="3.0" step="0.05" value="1.0">
                                    <span class="width-label">Wide</span>
                                    <span class="width-label" id="bp-width-value" style="font-weight:700;">1.0x</span>
                                </div>
                            </div>
                            <div id="boxplot"></div>
                            <p class="drag-hint">Drag the observed value (dark dot) left or right to see how the score changes.</p>
                            <div id="bp-coverage"></div>
                        </div>
                    </div>
                    <div class="description-section">
                        <h3>What is WIS?</h3>
                        <p class="definition">
                            WIS measures forecast quality by balancing <strong>sharpness</strong> (narrow intervals) with <strong>calibration</strong> (observations landing inside). Lower is better.
                        </p>
                        <p>WIS decomposes into three penalties:</p>
                        <div class="wis-component">
                            <span class="swatch" style="background:#5ACDC5;"></span>
                            <span><strong>Dispersion</strong> &mdash; how wide the intervals are</span>
                        </div>
                        <div class="wis-component">
                            <span class="swatch" style="background:#E87D5F;"></span>
                            <span><strong>Underprediction</strong> &mdash; observed &gt; upper bound</span>
                        </div>
                        <div class="wis-component">
                            <span class="swatch" style="background:#8B6DB0;"></span>
                            <span><strong>Overprediction</strong> &mdash; observed &lt; lower bound</span>
                        </div>

                        <div id="wis-decomp" style="margin-top:12px;"></div>

                        <div class="wis-scores">
                            <div class="wis-score-row">
                                <span class="wis-score-label">WIS (this date)</span>
                                <span class="wis-score-value" id="wis-model-val">&mdash;</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section 3: Collapsible math details -->
                <details class="math-details">
                    <summary>The Math Behind WIS</summary>
                    <div class="math-body">
                        <p><strong>Connection to CRPS.</strong> The Weighted Interval Score is a discrete approximation of the <strong>Continuous Ranked Probability Score (CRPS)</strong>, a standard scoring rule for probabilistic forecasts:</p>

                        <div class="math-eq">
                            CRPS(F, y) = &int;<sub>&minus;&infin;</sub><sup>&infin;</sup> (F(x) &minus; 1[x &ge; y])&sup2; dx
                        </div>

                        <p>where F is the forecast CDF and y is the observed value. CRPS measures the integrated squared distance between the forecast distribution and the step function at the observation. A perfect forecast gives CRPS = 0.</p>

                        <p>As the number of quantiles increases, WIS converges to CRPS, making it a practical way to score quantile-based forecasts.</p>

                        <span class="math-label">Interval Score for a (1&minus;&alpha;) prediction interval:</span>
                        <div class="math-eq">
                            IS<sub>&alpha;</sub>(l, u, y) = (u &minus; l) + (2/&alpha;)(l &minus; y) &middot; 1[y &lt; l] + (2/&alpha;)(y &minus; u) &middot; 1[y &gt; u]
                        </div>

                        <p>The three terms correspond to the three WIS components:</p>
                        <p><strong style="color:#5ACDC5;">(u &minus; l)</strong> = <strong>Dispersion</strong> &mdash; penalizes wide intervals. Wider intervals always increase this term.</p>
                        <p><strong style="color:#E87D5F;">(2/&alpha;)(y &minus; u)</strong> = <strong>Underprediction</strong> &mdash; when the observed value y falls above the upper bound u. The 2/&alpha; scaling means narrower PIs receive harsher penalties for misses:</p>
                        <ul>
                            <li>Missing a 95% PI (&alpha; = 0.05): penalty multiplier = 2/0.05 = <strong>40&times;</strong></li>
                            <li>Missing an 80% PI (&alpha; = 0.20): penalty multiplier = 2/0.20 = <strong>10&times;</strong></li>
                            <li>Missing a 50% PI (&alpha; = 0.50): penalty multiplier = 2/0.50 = <strong>4&times;</strong></li>
                        </ul>
                        <p>This asymmetric weighting ensures that forecasters cannot simply widen all intervals to guarantee coverage &mdash; the dispersion penalty counterbalances overly wide intervals.</p>
                        <p><strong style="color:#8B6DB0;">(2/&alpha;)(l &minus; y)</strong> = <strong>Overprediction</strong> &mdash; when y falls below the lower bound l, same scaling.</p>

                        <span class="math-label">Weighted Interval Score:</span>
                        <div class="math-eq">
                            WIS = 1/(K + 0.5) &middot; [ 0.5 &middot; |y &minus; m| + &sum;<sub>k=1</sub><sup>K</sup> (&alpha;<sub>k</sub>/2) &middot; IS<sub>&alpha;k</sub> ]
                        </div>

                        <p>where <em>m</em> is the predicted median, <em>K</em> is the number of interval pairs, and the weights &alpha;<sub>k</sub>/2 ensure that WIS converges to CRPS as the number of quantiles increases. The 0.5 &middot; |y &minus; m| term is the median absolute error, giving additional weight to point accuracy.</p>

                        <p><strong>Propriety.</strong> WIS is a <em>proper scoring rule</em>, meaning it is minimized in expectation when the forecaster reports their true belief about the future. This property incentivizes honest forecasting &mdash; a forecaster cannot systematically improve their score by misrepresenting their uncertainty.</p>

                        <div class="citation">
                            Bracher J, Ray EL, Gneiting T, Reich NG (2021). Evaluating epidemic forecasts in an interval format. <em>PLOS Computational Biology</em> 17(2): e1008618. <a href="https://doi.org/10.1371/journal.pcbi.1008618" target="_blank" rel="noopener">doi:10.1371/journal.pcbi.1008618</a>
                        </div>
                    </div>
                </details>

                <hr class="section-divider">

                <!-- Section 4: Relative WIS -->
                <h2 class="section-heading" style="margin-bottom:5px;">Relative WIS &mdash; Comparing to a Baseline</h2>
                <p class="section-sub">A score only has meaning in comparison. How does the model stack up against a simple baseline?</p>

                <div class="content-wrapper">
                    <div class="chart-section">
                        <div class="chart-container">
                            <h3 class="chart-title">Model vs. Baseline Forecast</h3>
                            <div id="rwis-chart"></div>
                        </div>
                    </div>
                    <div class="description-section">
                        <h3>The FluSight Baseline</h3>
                        <p>The <strong>FluSight baseline</strong> is a simple persistence model: it predicts the most recent observed value forward, using historical first differences to generate a prediction distribution.</p>
                        <p style="margin-top:10px;">A raw WIS number is hard to interpret on its own. Is 500 good? Bad? It depends on the difficulty of the prediction task. <strong>Relative WIS</strong> solves this by comparing to a baseline:</p>
                        <div class="math-eq" style="text-align:center; font-size:1.3rem;">
                            rWIS = WIS<sub>model</sub> / WIS<sub>baseline</sub>
                        </div>
                        <p><strong>rWIS &lt; 1</strong> means the model outperforms the baseline.<br>
                        <strong>rWIS &gt; 1</strong> means the baseline is better.</p>
                    </div>
                </div>
            </section>

            </div><!-- .main-content -->
        </div><!-- .app-layout -->
        </div><!-- #main-app -->
    </div><!-- .container -->

    <script>
/* ============================================================
   JAVASCRIPT
   ============================================================ */

// --- Constants ---
const FORECAST_URL = 'forecast.csv';
const SURVEILLANCE_URL = 'target.csv';
const BASELINE_URL = 'forecast_baseline.csv';

const COLORS = {
    observed: '#1C2442',
    forecast: '#1E9CC5',
    pi95: '#DFF8ED',
    pi80: '#5ACDC5',
    pi50: '#344D84',
    baseline: '#999999'
};

const Z_SCORES = {
    '0.01': -2.3263, '0.025': -1.9600, '0.05': -1.6449,
    '0.1': -1.2816, '0.15': -1.0364, '0.2': -0.8416,
    '0.25': -0.6745, '0.3': -0.5244, '0.35': -0.3853,
    '0.4': -0.2533, '0.45': -0.1257, '0.5': 0,
    '0.55': 0.1257, '0.6': 0.2533, '0.65': 0.3853,
    '0.7': 0.5244, '0.75': 0.6745, '0.8': 0.8416,
    '0.85': 1.0364, '0.9': 1.2816, '0.95': 1.6449,
    '0.975': 1.9600, '0.99': 2.3263
};

const WIS_PAIRS = [
    {alpha: 0.02, lower: '0.01',  upper: '0.99'},
    {alpha: 0.05, lower: '0.025', upper: '0.975'},
    {alpha: 0.10, lower: '0.05',  upper: '0.95'},
    {alpha: 0.20, lower: '0.1',   upper: '0.9'},
    {alpha: 0.30, lower: '0.15',  upper: '0.85'},
    {alpha: 0.40, lower: '0.2',   upper: '0.8'},
    {alpha: 0.50, lower: '0.25',  upper: '0.75'},
    {alpha: 0.60, lower: '0.3',   upper: '0.7'},
    {alpha: 0.70, lower: '0.35',  upper: '0.65'},
    {alpha: 0.80, lower: '0.4',   upper: '0.6'},
    {alpha: 0.90, lower: '0.45',  upper: '0.55'},
];

const PI_TO_PAIRS = {
    95: [
        {alpha: 0.02, lower: '0.01',  upper: '0.99'},
        {alpha: 0.05, lower: '0.025', upper: '0.975'},
        {alpha: 0.10, lower: '0.05',  upper: '0.95'},
    ],
    80: [
        {alpha: 0.20, lower: '0.1',   upper: '0.9'},
        {alpha: 0.30, lower: '0.15',  upper: '0.85'},
        {alpha: 0.40, lower: '0.2',   upper: '0.8'},
    ],
    50: [
        {alpha: 0.50, lower: '0.25',  upper: '0.75'},
        {alpha: 0.60, lower: '0.3',   upper: '0.7'},
        {alpha: 0.70, lower: '0.35',  upper: '0.65'},
        {alpha: 0.80, lower: '0.4',   upper: '0.6'},
        {alpha: 0.90, lower: '0.45',  upper: '0.55'},
    ],
};

// Synthetic data for boxplot section
const SYNTH_DATA = [
    { date: new Date('2025-11-08'), observed: 1774, modelMedian: 1650, baselineMedian: 1348 },
    { date: new Date('2025-11-15'), observed: 2417, modelMedian: 2500, baselineMedian: 1774 },
    { date: new Date('2025-11-22'), observed: 3528, modelMedian: 3200, baselineMedian: 2417 },
    { date: new Date('2025-11-29'), observed: 5133, modelMedian: 5400, baselineMedian: 3528 },
    { date: new Date('2025-12-06'), observed: 7397, modelMedian: 7100, baselineMedian: 5133 },
];

let chartData = null;
let bpObservedValue = null;

// --- Scoring Functions ---
function generateQuantiles(median, sigma) {
    const q = {};
    Object.entries(Z_SCORES).forEach(([level, z]) => {
        q[level] = Math.max(0, median + z * sigma);
    });
    return q;
}

function computeWIS(allQ, y, pairs) {
    pairs = pairs || WIS_PAIRS;
    const median = allQ['0.5'];
    const K = pairs.length;
    let dispersion = 0, underpred = 0, overpred = 0;

    pairs.forEach(({alpha, lower, upper}) => {
        const l = allQ[lower], u = allQ[upper];
        const w = alpha / 2;
        dispersion += w * (u - l);
        if (y > u) underpred += w * (2 / alpha) * (y - u);
        if (y < l) overpred  += w * (2 / alpha) * (l - y);
    });

    const absErr = 0.5 * Math.abs(y - median);
    const denom = K + 0.5;
    return {
        dispersion: dispersion / denom,
        underprediction: underpred / denom,
        overprediction: overpred / denom,
        total: (dispersion + underpred + overpred + absErr) / denom
    };
}

// Generate out-of-sample "observed" values (projected from surveillance trend)
function getOOSValues(surveillance, forecastDates) {
    const n = surveillance.length;
    const lastVal = surveillance[n - 1].value;
    const growthRate = lastVal / surveillance[n - 2].value;
    const dampedRate = 1 + (growthRate - 1) * 0.6;
    let prev = lastVal;
    return forecastDates.map((d, i) => {
        prev = prev * dampedRate;
        const noise = Math.sin(i * 5.7 + 1.3) * prev * 0.04;
        return { date: d.date, value: prev + noise };
    });
}

// --- Data Loading ---
async function loadData() {
    try {
        const [forecastRaw, surveillanceRaw, baselineRaw] = await Promise.all([
            d3.csv(FORECAST_URL),
            d3.csv(SURVEILLANCE_URL),
            d3.csv(BASELINE_URL)
        ]);

        // Process forecast data
        const forecastByDate = d3.group(forecastRaw, d => d.target_end_date);
        const forecastData = Array.from(forecastByDate, ([date, rows]) => {
            const q = {};
            rows.forEach(r => {
                if (r.output_type === 'quantile') q[r.output_type_id] = +r.value;
            });
            return {
                date: new Date(date),
                q025: q['0.025'], q100: q['0.1'], q250: q['0.25'],
                q500: q['0.5'], q750: q['0.75'], q900: q['0.9'], q975: q['0.975'],
                allQ: q
            };
        }).sort((a, b) => a.date - b.date);

        // Process surveillance data
        const byDate = d3.rollup(
            surveillanceRaw,
            v => d3.max(v, d => +d.observation || 0),
            d => d.target_end_date
        );
        const surveillanceData = Array.from(byDate, ([date, value]) => ({
            date: new Date(date),
            value: value
        })).sort((a, b) => a.date - b.date);

        // Process baseline data
        const baselineUS = baselineRaw.filter(r => r.location === 'US' && r.output_type === 'quantile' && r.horizon !== '-1');
        const baselineByDate = d3.group(baselineUS, d => d.target_end_date);
        const baselineData = Array.from(baselineByDate, ([date, rows]) => {
            const q = {};
            rows.forEach(r => { q[r.output_type_id] = +r.value; });
            return {
                date: new Date(date),
                q025: q['0.025'], q100: q['0.1'], q250: q['0.25'],
                q500: q['0.5'], q750: q['0.75'], q900: q['0.9'], q975: q['0.975'],
                allQ: q
            };
        }).sort((a, b) => a.date - b.date);

        chartData = { forecast: forecastData, surveillance: surveillanceData, baseline: baselineData };

        document.getElementById('loading').style.display = 'none';
        document.getElementById('main-app').style.display = 'block';

        drawChart([95, 80, 50]);
        setupControls();
        setupNavigation();
        bpObservedValue = SYNTH_DATA[2].observed;
        setupBoxplotControls();
        setupWISBoxControls();

    } catch (error) {
        console.error('Error:', error);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error').textContent = `Error: ${error.message}`;
    }
}

// --- Chart: PI ---
function drawChart(enabledIntervals) {
    const { forecast, surveillance } = chartData;

    d3.select('#chart').selectAll('*').remove();

    const margin = {top: 20, right: 30, bottom: 50, left: 70};
    const container = document.getElementById('chart');
    const width = container.clientWidth - margin.left - margin.right;
    const height = 380 - margin.top - margin.bottom;

    const svgEl = d3.select('#chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    const svg = svgEl.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const rc = rough.svg(svgEl.node());

    const allDates = [...surveillance.map(d => d.date), ...forecast.map(d => d.date)];
    const allValues = [
        ...surveillance.map(d => d.value),
        ...forecast.flatMap(d => [d.q025, d.q975])
    ];

    const xScale = d3.scaleTime().domain(d3.extent(allDates)).range([0, width]);
    const yScale = d3.scaleLinear().domain([0, d3.max(allValues) * 1.1]).range([height, 0]);

    // Axes
    svg.node().appendChild(rc.line(0, height, width, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 1 }));
    svg.node().appendChild(rc.line(0, 0, 0, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 2 }));

    xScale.ticks(6).forEach((tick, i) => {
        const x = xScale(tick);
        svg.node().appendChild(rc.line(x, height, x, height + 6, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 10 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', x).attr('y', height + 20).attr('text-anchor', 'middle').text(d3.timeFormat('%b %d')(tick));
    });

    yScale.ticks(6).forEach((tick, i) => {
        const y = yScale(tick);
        svg.node().appendChild(rc.line(-6, y, 0, y, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 20 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', -10).attr('y', y + 4).attr('text-anchor', 'end').text(d3.format(',')(tick));
    });

    svg.append('text').attr('class', 'axis-label').attr('transform', 'rotate(-90)').attr('y', -55).attr('x', -height / 2).attr('text-anchor', 'middle').text('Weekly Hospitalizations');
    svg.append('text').attr('class', 'axis-label').attr('x', width / 2).attr('y', height + 42).attr('text-anchor', 'middle').text('Week');

    // PI areas
    const pis = [
        {level: 95, lower: 'q025', upper: 'q975', color: COLORS.pi95, opacity: 0.3},
        {level: 80, lower: 'q100', upper: 'q900', color: COLORS.pi80, opacity: 0.4},
        {level: 50, lower: 'q250', upper: 'q750', color: COLORS.pi50, opacity: 0.5}
    ];

    pis.forEach(pi => {
        if (!enabledIntervals.includes(pi.level)) return;
        const area = d3.area().x(d => xScale(d.date)).y0(d => yScale(d[pi.lower])).y1(d => yScale(d[pi.upper]));
        const sketchyPath = rc.path(area(forecast), {
            fill: pi.color, fillStyle: 'solid', fillWeight: 1, stroke: 'none', roughness: 1.5, seed: pi.level
        });
        sketchyPath.style.opacity = pi.opacity;
        svg.node().appendChild(sketchyPath);

        // Bound lines
        [pi.lower, pi.upper].forEach((key, j) => {
            const line = d3.line().x(d => xScale(d.date)).y(d => yScale(d[key]));
            svg.node().appendChild(rc.path(line(forecast), {
                stroke: pi.color, strokeWidth: 1.5, roughness: 1.2, fill: 'none', seed: pi.level + j + 1
            }));
        });
    });

    // Median forecast line
    const medianLine = d3.line().x(d => xScale(d.date)).y(d => yScale(d.q500));
    svg.node().appendChild(rc.path(medianLine(forecast), {
        stroke: COLORS.forecast, strokeWidth: 2.5, roughness: 1.2, fill: 'none', seed: 42
    }));

    // Observed dots
    surveillance.forEach(d => {
        svg.node().appendChild(rc.circle(xScale(d.date), yScale(d.value), 10, {
            fill: COLORS.observed, fillStyle: 'solid', stroke: COLORS.observed, strokeWidth: 1, roughness: 1, seed: Math.round(d.value)
        }));
    });

    // Legend
    const legend = svg.append('g').attr('transform', `translate(${width - 150}, 20)`);
    legend.node().appendChild(rc.circle(15, 0, 8, { fill: COLORS.observed, fillStyle: 'solid', stroke: COLORS.observed, roughness: 1, seed: 99 }));
    legend.append('text').attr('class', 'legend-text').attr('x', 25).attr('y', 4).text('Observed');
    legend.node().appendChild(rc.line(0, 20, 30, 20, { stroke: COLORS.forecast, strokeWidth: 2.5, roughness: 1.2, seed: 100 }));
    legend.append('text').attr('class', 'legend-text').attr('x', 35).attr('y', 24).text('Forecast');
}

function setupControls() {
    document.querySelectorAll('.toggle-btn[data-interval]').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.classList.toggle('active');
            const enabled = Array.from(document.querySelectorAll('.toggle-btn.active[data-interval]'))
                .map(b => parseInt(b.dataset.interval));
            drawChart(enabled);
        });
    });
}

// --- Chart: WIS Box (Section 1) ---
function drawBoxChart(enabledIntervals) {
    const { forecast, surveillance } = chartData;

    d3.select('#wis-box-chart').selectAll('*').remove();

    const margin = {top: 20, right: 30, bottom: 50, left: 70};
    const container = document.getElementById('wis-box-chart');
    const width = container.clientWidth - margin.left - margin.right;
    const height = 380 - margin.top - margin.bottom;

    const svgEl = d3.select('#wis-box-chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    const svg = svgEl.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const rc = rough.svg(svgEl.node());

    const allDates = [...surveillance.map(d => d.date), ...forecast.map(d => d.date)];
    const allValues = [
        ...surveillance.map(d => d.value),
        ...forecast.flatMap(d => [d.q025, d.q975])
    ];

    const xScale = d3.scaleTime().domain(d3.extent(allDates)).range([0, width]);
    const yScale = d3.scaleLinear().domain([0, d3.max(allValues) * 1.1]).range([height, 0]);

    // Axes
    svg.node().appendChild(rc.line(0, height, width, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 1 }));
    svg.node().appendChild(rc.line(0, 0, 0, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 2 }));

    xScale.ticks(6).forEach((tick, i) => {
        const x = xScale(tick);
        svg.node().appendChild(rc.line(x, height, x, height + 6, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 10 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', x).attr('y', height + 20).attr('text-anchor', 'middle').text(d3.timeFormat('%b %d')(tick));
    });

    yScale.ticks(6).forEach((tick, i) => {
        const y = yScale(tick);
        svg.node().appendChild(rc.line(-6, y, 0, y, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 20 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', -10).attr('y', y + 4).attr('text-anchor', 'end').text(d3.format(',')(tick));
    });

    svg.append('text').attr('class', 'axis-label').attr('transform', 'rotate(-90)').attr('y', -55).attr('x', -height / 2).attr('text-anchor', 'middle').text('Weekly Hospitalizations');
    svg.append('text').attr('class', 'axis-label').attr('x', width / 2).attr('y', height + 42).attr('text-anchor', 'middle').text('Week');

    // Band half-width
    const dateSpan = forecast.length > 1 ? xScale(forecast[1].date) - xScale(forecast[0].date) : 60;
    const bandHW = Math.min(dateSpan * 0.35, 28);

    // PI rectangles at each forecast date
    const pis = [
        {level: 95, lower: 'q025', upper: 'q975', color: COLORS.pi95, opacity: 0.6},
        {level: 80, lower: 'q100', upper: 'q900', color: COLORS.pi80, opacity: 0.7},
        {level: 50, lower: 'q250', upper: 'q750', color: COLORS.pi50, opacity: 0.8},
    ];

    pis.forEach(pi => {
        if (!enabledIntervals.includes(pi.level)) return;
        forecast.forEach((d, i) => {
            const cx = xScale(d.date);
            const top = yScale(d[pi.upper]);
            const bot = yScale(d[pi.lower]);
            const rect = rc.rectangle(cx - bandHW, top, bandHW * 2, bot - top, {
                fill: pi.color, fillStyle: 'solid', stroke: pi.color, strokeWidth: 1, roughness: 1.2, seed: pi.level * 100 + i
            });
            rect.style.opacity = pi.opacity;
            svg.node().appendChild(rect);
        });
    });

    // Median blue line — horizontal segment within each box only
    forecast.forEach((d, i) => {
        const cx = xScale(d.date);
        const my = yScale(d.q500);
        svg.node().appendChild(rc.line(cx - bandHW, my, cx + bandHW, my, {
            stroke: COLORS.forecast, strokeWidth: 2.5, roughness: 0.8, seed: 42 + i
        }));
    });

    // Out-of-sample dots (white fill, dark border) — noisy increasing trend
    const oosData = getOOSValues(surveillance, forecast);
    oosData.forEach((d, i) => {
        svg.node().appendChild(rc.circle(xScale(d.date), yScale(d.value), 10, {
            fill: 'white', fillStyle: 'solid', stroke: COLORS.observed, strokeWidth: 2, roughness: 0.8, seed: 500 + i
        }));
    });

    // Observed line + dots
    const obsLine = d3.line().x(d => xScale(d.date)).y(d => yScale(d.value));
    svg.node().appendChild(rc.path(obsLine(surveillance), {
        stroke: COLORS.observed, strokeWidth: 2, roughness: 1, fill: 'none', seed: 550
    }));
    surveillance.forEach((d, i) => {
        svg.node().appendChild(rc.circle(xScale(d.date), yScale(d.value), 10, {
            fill: COLORS.observed, fillStyle: 'solid', stroke: COLORS.observed, strokeWidth: 1, roughness: 1, seed: 560 + i
        }));
    });

    // Legend
    const lg = svg.append('g').attr('transform', `translate(${width - 200}, 10)`);
    lg.node().appendChild(rc.circle(8, 0, 8, { fill: COLORS.observed, fillStyle: 'solid', stroke: COLORS.observed, roughness: 0.8, seed: 570 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 18).attr('y', 4).text('Observed');
    lg.node().appendChild(rc.circle(8, 18, 8, { fill: 'white', fillStyle: 'solid', stroke: COLORS.observed, strokeWidth: 2, roughness: 0.8, seed: 571 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 18).attr('y', 22).text('Out-of-sample');
    lg.node().appendChild(rc.line(0, 36, 16, 36, { stroke: COLORS.forecast, strokeWidth: 2.5, roughness: 0.8, seed: 572 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 22).attr('y', 40).text('Forecast median');
}

function setupWISBoxControls() {
    document.querySelectorAll('.toggle-btn[data-wis-box-interval]').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.classList.toggle('active');
            const enabled = Array.from(document.querySelectorAll('.toggle-btn.active[data-wis-box-interval]'))
                .map(b => parseInt(b.dataset.wisBoxInterval));
            drawBoxChart(enabled);
        });
    });
}

// --- Chart: Boxplot (Section 2) ---
function getBPEnabledPIs() {
    return Array.from(document.querySelectorAll('.toggle-btn.active[data-bp-interval]'))
        .map(b => parseInt(b.dataset.bpInterval));
}

function getBPWidth() {
    return parseFloat(document.getElementById('bp-width-slider').value);
}

function redrawBoxplot() {
    drawBoxplot(bpObservedValue, getBPWidth(), getBPEnabledPIs());
}

function renderObservedDot(svg, rc, xScale, obsVal, centerY, allQ, enabledPIs) {
    svg.selectAll('.obs-group').remove();

    const obsG = svg.select('.drag-overlay').empty()
        ? svg.append('g').attr('class', 'obs-group')
        : svg.insert('g', '.drag-overlay').attr('class', 'obs-group');

    const obsX = xScale(obsVal);

    obsG.node().appendChild(rc.line(obsX, centerY - 45, obsX, centerY + 45, {
        stroke: COLORS.observed, strokeWidth: 1, roughness: 0.6, strokeLineDash: [4, 4], seed: 461
    }));

    obsG.node().appendChild(rc.circle(obsX, centerY, 14, {
        fill: COLORS.observed, fillStyle: 'solid', stroke: '#fff', strokeWidth: 2, roughness: 1, seed: 460
    }));

    obsG.append('text').attr('class', 'tick-label')
        .attr('x', obsX).attr('y', centerY - 50)
        .attr('text-anchor', 'middle')
        .style('font-weight', '700').style('font-size', '13px')
        .text('Observed: ' + d3.format(',')(Math.round(obsVal)));

    updateBPCoverage(allQ, obsVal, enabledPIs);
    const activePairs = enabledPIs.flatMap(level => PI_TO_PAIRS[level] || []);
    const wis = computeWIS(allQ, obsVal, activePairs.length > 0 ? activePairs : WIS_PAIRS);
    document.getElementById('wis-model-val').textContent = Math.round(wis.total).toLocaleString();
    drawWISDecomp(wis);
}

function drawBoxplot(obsVal, widthFactor, enabledPIs) {
    const d = SYNTH_DATA[2];
    const sigma = d.observed * 0.12 * widthFactor;
    const allQ = generateQuantiles(d.modelMedian, sigma);

    d3.select('#boxplot').selectAll('*').remove();

    const container = document.getElementById('boxplot');
    const margin = {top: 30, right: 30, bottom: 40, left: 20};
    const W = container.clientWidth - margin.left - margin.right;
    const H = 130;

    const svgEl = d3.select('#boxplot')
        .append('svg')
        .attr('width', W + margin.left + margin.right)
        .attr('height', H + margin.top + margin.bottom);

    const svg = svgEl.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const rc = rough.svg(svgEl.node());

    const maxQ = d.modelMedian + 1.96 * d.observed * 0.12 * 3.0;
    const minQ = Math.max(0, d.modelMedian - 1.96 * d.observed * 0.12 * 3.0);
    const xScale = d3.scaleLinear().domain([minQ * 0.8, maxQ * 1.1]).range([0, W]);

    // Axis
    svg.node().appendChild(rc.line(0, H, W, H, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 300 }));

    xScale.ticks(8).forEach((tick, i) => {
        const x = xScale(tick);
        svg.node().appendChild(rc.line(x, H, x, H + 6, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 310 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', x).attr('y', H + 20).attr('text-anchor', 'middle').text(d3.format(',')(tick));
    });

    svg.append('text').attr('class', 'axis-label').attr('x', W / 2).attr('y', H + 38).attr('text-anchor', 'middle').text('Weekly Hospitalizations');

    const piDefs = [
        { level: 95, lower: '0.025', upper: '0.975', color: COLORS.pi95, barH: 60 },
        { level: 80, lower: '0.1',   upper: '0.9',   color: COLORS.pi80, barH: 40 },
        { level: 50, lower: '0.25',  upper: '0.75',  color: COLORS.pi50, barH: 22 },
    ];

    const centerY = H / 2;

    // Draw PI bars (widest first)
    piDefs.forEach((pi, i) => {
        if (!enabledPIs.includes(pi.level)) return;
        const x1 = xScale(allQ[pi.lower]);
        const x2 = xScale(allQ[pi.upper]);
        const y = centerY - pi.barH / 2;
        svg.node().appendChild(rc.rectangle(x1, y, x2 - x1, pi.barH, {
            fill: pi.color, fillStyle: 'solid', stroke: pi.color, strokeWidth: 1.5, roughness: 1.2, seed: 400 + i
        }));
        svg.append('text').attr('class', 'legend-text')
            .attr('x', (x1 + x2) / 2).attr('y', centerY - pi.barH / 2 - 4)
            .attr('text-anchor', 'middle').style('font-size', '11px')
            .text(pi.level + '% PI');
    });

    // Median line — drawn AFTER PI bars so it renders on top
    // Height covers full extent of largest enabled PI
    const maxBarH = piDefs.filter(p => enabledPIs.includes(p.level)).reduce((m, p) => Math.max(m, p.barH), 30);
    const medX = xScale(allQ['0.5']);
    svg.node().appendChild(rc.line(medX, centerY - maxBarH / 2 - 5, medX, centerY + maxBarH / 2 + 5, {
        stroke: COLORS.forecast, strokeWidth: 2.5, roughness: 0.8, seed: 450
    }));

    // Annotation
    let annotation = '';
    if (widthFactor < 0.5) annotation = 'Too sharp! Observations fall outside \u2014 large penalty';
    else if (widthFactor < 0.8) annotation = 'Sharper intervals, but some coverage misses';
    else if (widthFactor <= 1.3) annotation = 'Good balance of sharpness and calibration';
    else if (widthFactor <= 2.0) annotation = 'Wide intervals \u2014 high dispersion penalty';
    else annotation = 'Very wide \u2014 safe coverage but poor sharpness';

    svg.append('text').attr('class', 'tick-label')
        .attr('x', W / 2).attr('y', -8)
        .attr('text-anchor', 'middle')
        .style('fill', '#666').style('font-size', '13px')
        .text(annotation);

    // Observed dot
    renderObservedDot(svg, rc, xScale, obsVal, centerY, allQ, enabledPIs);

    // Drag overlay
    svg.append('rect')
        .attr('class', 'drag-overlay')
        .attr('x', 0).attr('y', 0)
        .attr('width', W).attr('height', H)
        .attr('fill', 'transparent')
        .style('cursor', 'ew-resize')
        .call(d3.drag()
            .on('drag', function(event) {
                const newVal = xScale.invert(Math.max(0, Math.min(W, event.x)));
                bpObservedValue = newVal;
                renderObservedDot(svg, rc, xScale, newVal, centerY, allQ, enabledPIs);
            })
        );
}

function updateBPCoverage(allQ, obsVal, enabledPIs) {
    const el = document.getElementById('bp-coverage');
    el.innerHTML = '';
    const piChecks = [
        { level: 95, lower: '0.025', upper: '0.975' },
        { level: 80, lower: '0.1',   upper: '0.9'   },
        { level: 50, lower: '0.25',  upper: '0.75'  },
    ];
    piChecks.forEach(pi => {
        if (!enabledPIs.includes(pi.level)) return;
        const inRange = obsVal >= allQ[pi.lower] && obsVal <= allQ[pi.upper];
        const row = document.createElement('div');
        row.className = 'coverage-row';
        row.innerHTML = `<span class="coverage-check ${inRange ? 'coverage-hit' : 'coverage-miss'}">${inRange ? '&#10003;' : '&#10007;'}</span>
            <span>${pi.level}% PI: ${inRange ? 'Covered' : 'Miss'} [${d3.format(',')(Math.round(allQ[pi.lower]))} \u2013 ${d3.format(',')(Math.round(allQ[pi.upper]))}]</span>`;
        el.appendChild(row);
    });
}

function setupBoxplotControls() {
    document.querySelectorAll('.toggle-btn[data-bp-interval]').forEach(btn => {
        btn.addEventListener('click', () => {
            btn.classList.toggle('active');
            redrawBoxplot();
        });
    });

    const slider = document.getElementById('bp-width-slider');
    const label = document.getElementById('bp-width-value');
    slider.addEventListener('input', () => {
        label.textContent = parseFloat(slider.value).toFixed(1) + 'x';
        redrawBoxplot();
    });
}

// --- WIS Decomposition Bar ---
function drawWISDecomp(wis) {
    const el = d3.select('#wis-decomp');
    el.selectAll('*').remove();

    const total = wis.total;
    if (total === 0) return;

    const barW = 260, barH = 26;
    const svgBar = el.append('svg').attr('width', barW + 10).attr('height', barH + 28);
    const rc = rough.svg(svgBar.node());

    const parts = [
        { label: 'Dispersion', value: wis.dispersion, color: '#5ACDC5' },
        { label: 'Under', value: wis.underprediction, color: '#E87D5F' },
        { label: 'Over', value: wis.overprediction, color: '#8B6DB0' },
    ];

    let x = 0;
    parts.forEach((p, i) => {
        const w = (p.value / total) * barW;
        if (w > 1) {
            svgBar.node().appendChild(rc.rectangle(x, 0, w, barH, {
                fill: p.color, fillStyle: 'solid', stroke: 'none', roughness: 0.8, seed: 1000 + i
            }));
            if (w > 40) {
                svgBar.append('text').attr('x', x + w / 2).attr('y', barH / 2 + 5)
                    .attr('text-anchor', 'middle').attr('class', 'tick-label')
                    .style('fill', 'white').style('font-size', '11px')
                    .text(Math.round(p.value));
            }
            x += w;
        }
    });

    x = 0;
    parts.forEach(p => {
        const w = (p.value / total) * barW;
        if (w > 30) {
            svgBar.append('text').attr('x', x + w / 2).attr('y', barH + 16)
                .attr('text-anchor', 'middle')
                .style('font-size', '10px').style('fill', '#1C2442')
                .style('font-family', "'Patrick Hand', cursive")
                .text(p.label);
        }
        x += w;
    });
}

// --- Chart: rWIS (Section 4) ---
function drawRWISChart() {
    const { forecast, surveillance, baseline } = chartData;

    d3.select('#rwis-chart').selectAll('*').remove();

    const margin = {top: 20, right: 30, bottom: 50, left: 70};
    const container = document.getElementById('rwis-chart');
    const width = container.clientWidth - margin.left - margin.right;
    const height = 380 - margin.top - margin.bottom;

    const svgEl = d3.select('#rwis-chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    const svg = svgEl.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const rc = rough.svg(svgEl.node());

    const allDates = [...surveillance.map(d => d.date), ...forecast.map(d => d.date), ...baseline.map(d => d.date)];
    const allValues = [
        ...surveillance.map(d => d.value),
        ...forecast.flatMap(d => [d.q100, d.q900]),
        ...baseline.map(d => d.q900)
    ];

    const xScale = d3.scaleTime().domain(d3.extent(allDates)).range([0, width]);
    const yScale = d3.scaleLinear().domain([0, d3.max(allValues) * 1.1]).range([height, 0]);

    // Axes
    svg.node().appendChild(rc.line(0, height, width, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 1 }));
    svg.node().appendChild(rc.line(0, 0, 0, height, { stroke: '#1C2442', strokeWidth: 1.5, roughness: 0.8, seed: 2 }));

    xScale.ticks(6).forEach((tick, i) => {
        const x = xScale(tick);
        svg.node().appendChild(rc.line(x, height, x, height + 6, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 10 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', x).attr('y', height + 20).attr('text-anchor', 'middle').text(d3.timeFormat('%b %d')(tick));
    });

    yScale.ticks(6).forEach((tick, i) => {
        const y = yScale(tick);
        svg.node().appendChild(rc.line(-6, y, 0, y, { stroke: '#1C2442', strokeWidth: 1, roughness: 0.5, seed: 20 + i }));
        svg.append('text').attr('class', 'tick-label').attr('x', -10).attr('y', y + 4).attr('text-anchor', 'end').text(d3.format(',')(tick));
    });

    svg.append('text').attr('class', 'axis-label').attr('transform', 'rotate(-90)').attr('y', -55).attr('x', -height / 2).attr('text-anchor', 'middle').text('Weekly Hospitalizations');
    svg.append('text').attr('class', 'axis-label').attr('x', width / 2).attr('y', height + 42).attr('text-anchor', 'middle').text('Week');

    // Band half-width
    const dateSpan = forecast.length > 1 ? xScale(forecast[1].date) - xScale(forecast[0].date) : 60;
    const bandHW = Math.min(dateSpan * 0.22, 22);
    const gap = 3;

    // --- Draw BASELINE first (behind) ---
    // Baseline 80% PI boxes (right side, gray hachure)
    baseline.forEach((d, i) => {
        const cx = xScale(d.date) + gap / 2;
        const upper = d.q900;
        const lower = Math.max(d.q100, d.q500 * 0.3);
        const top = yScale(upper);
        const bot = yScale(lower);
        svg.node().appendChild(rc.rectangle(cx, top, bandHW * 2, bot - top, {
            fill: COLORS.baseline, fillStyle: 'hachure',
            fillWeight: 1.5, hachureGap: 5,
            stroke: COLORS.baseline, strokeWidth: 1,
            roughness: 1.2, seed: 2200 + i
        }));
    });

    // Baseline 50% PI boxes (right side, gray hachure)
    baseline.forEach((d, i) => {
        const cx = xScale(d.date) + gap / 2;
        const top = yScale(d.q750);
        const bot = yScale(d.q250);
        svg.node().appendChild(rc.rectangle(cx + bandHW * 0.3, top, bandHW * 1.4, bot - top, {
            fill: COLORS.baseline, fillStyle: 'hachure',
            fillWeight: 2, hachureGap: 4,
            stroke: COLORS.baseline, strokeWidth: 1,
            roughness: 1.2, seed: 2300 + i
        }));
    });

    // --- Draw MODEL on top ---
    // Model 80% PI boxes (left side)
    forecast.forEach((d, i) => {
        const cx = xScale(d.date) - gap / 2 - bandHW;
        const top = yScale(d.q900);
        const bot = yScale(d.q100);
        const rect = rc.rectangle(cx, top, bandHW * 2, bot - top, {
            fill: COLORS.pi95, fillStyle: 'solid',
            stroke: COLORS.pi80, strokeWidth: 1,
            roughness: 1.2, seed: 2000 + i
        });
        rect.style.opacity = 0.6;
        svg.node().appendChild(rect);
    });

    // Model 50% PI boxes (left side)
    forecast.forEach((d, i) => {
        const cx = xScale(d.date) - gap / 2 - bandHW;
        const top = yScale(d.q750);
        const bot = yScale(d.q250);
        const rect = rc.rectangle(cx + bandHW * 0.3, top, bandHW * 1.4, bot - top, {
            fill: COLORS.pi50, fillStyle: 'solid',
            stroke: COLORS.pi50, strokeWidth: 1,
            roughness: 1.2, seed: 2100 + i
        });
        rect.style.opacity = 0.8;
        svg.node().appendChild(rect);
    });

    // Out-of-sample dots (noisy increasing trend)
    const oosData = getOOSValues(surveillance, forecast);
    oosData.forEach((d, i) => {
        svg.node().appendChild(rc.circle(xScale(d.date), yScale(d.value), 10, {
            fill: 'white', fillStyle: 'solid',
            stroke: COLORS.observed, strokeWidth: 2,
            roughness: 0.8, seed: 2400 + i
        }));
    });

    // Baseline median dots (gray)
    baseline.forEach((d, i) => {
        svg.node().appendChild(rc.circle(xScale(d.date) + gap / 2 + bandHW, yScale(d.q500), 8, {
            fill: COLORS.baseline, fillStyle: 'solid',
            stroke: COLORS.baseline, strokeWidth: 1,
            roughness: 0.8, seed: 2500 + i
        }));
    });

    // Observed line + dots
    const obsLine = d3.line().x(d => xScale(d.date)).y(d => yScale(d.value));
    svg.node().appendChild(rc.path(obsLine(surveillance), {
        stroke: COLORS.observed, strokeWidth: 2, roughness: 1, fill: 'none', seed: 2600
    }));
    surveillance.forEach((d, i) => {
        svg.node().appendChild(rc.circle(xScale(d.date), yScale(d.value), 10, {
            fill: COLORS.observed, fillStyle: 'solid',
            stroke: COLORS.observed, strokeWidth: 1,
            roughness: 1, seed: 2610 + i
        }));
    });

    // Legend
    const lg = svg.append('g').attr('transform', `translate(${width - 200}, 10)`);
    lg.node().appendChild(rc.circle(8, 0, 8, { fill: COLORS.observed, fillStyle: 'solid', stroke: COLORS.observed, roughness: 0.8, seed: 2700 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 18).attr('y', 4).text('Observed');
    lg.node().appendChild(rc.circle(8, 16, 8, { fill: 'white', fillStyle: 'solid', stroke: COLORS.observed, strokeWidth: 2, roughness: 0.8, seed: 2703 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 18).attr('y', 20).text('Out-of-sample');
    lg.node().appendChild(rc.rectangle(0, 28, 16, 10, { fill: COLORS.pi80, fillStyle: 'solid', stroke: 'none', roughness: 0.8, seed: 2701 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 22).attr('y', 38).text('Model');
    lg.node().appendChild(rc.rectangle(0, 44, 16, 10, { fill: COLORS.baseline, fillStyle: 'hachure', fillWeight: 1.5, hachureGap: 4, stroke: COLORS.baseline, roughness: 0.8, seed: 2702 }));
    lg.append('text').attr('class', 'legend-text').attr('x', 22).attr('y', 54).text('Baseline');

    // --- Compute real WIS ---
    const baselineByDateMap = {};
    baseline.forEach(d => { baselineByDateMap[d.date.toISOString().slice(0, 10)] = d; });

    const survByDate = {};
    surveillance.forEach(d => { survByDate[d.date.toISOString().slice(0, 10)] = d.value; });

    let modelWISSum = 0, baselineWISSum = 0, matchCount = 0;

    forecast.forEach(fd => {
        const dateKey = fd.date.toISOString().slice(0, 10);
        const obs = survByDate[dateKey];
        const bd = baselineByDateMap[dateKey];
        if (obs !== undefined && bd) {
            modelWISSum += computeWIS(fd.allQ, obs).total;
            baselineWISSum += computeWIS(bd.allQ, obs).total;
            matchCount++;
        }
    });

    if (matchCount > 0) {
        const avgModel = modelWISSum / matchCount;
        const avgBaseline = baselineWISSum / matchCount;
        const rWIS = avgBaseline > 0 ? avgModel / avgBaseline : NaN;

        document.getElementById('wis-avg-model-val').textContent = Math.round(avgModel).toLocaleString();
        document.getElementById('wis-baseline-val').textContent = Math.round(avgBaseline).toLocaleString();

        const rwisEl = document.getElementById('rwis-val');
        rwisEl.textContent = rWIS.toFixed(2);
        rwisEl.className = 'rwis-value ' + (rWIS < 1 ? 'rwis-good' : 'rwis-bad');

        const interpEl = document.getElementById('rwis-interp');
        if (rWIS < 1) interpEl.textContent = `Model is ${Math.round((1 - rWIS) * 100)}% better than the baseline`;
        else if (rWIS > 1) interpEl.textContent = `Model is ${Math.round((rWIS - 1) * 100)}% worse than the baseline`;
        else interpEl.textContent = 'Model performs the same as baseline';
    } else {
        document.getElementById('wis-avg-model-val').textContent = 'N/A';
        document.getElementById('wis-baseline-val').textContent = 'N/A';
        document.getElementById('rwis-val').textContent = 'N/A';
        document.getElementById('rwis-interp').textContent = 'No overlapping dates between forecast, baseline, and observations';
    }
}

// --- Charts: Categorical Forecasts (Trend + Activity horizontal bars) ---
function drawHorizontalBarChart(containerId, categories, probs, colors, seedBase) {
    d3.select('#' + containerId).selectAll('*').remove();

    const container = document.getElementById(containerId);
    const margin = {top: 8, right: 60, bottom: 10, left: 120};
    const width = container.clientWidth - margin.left - margin.right;
    const barHeight = 32;
    const gap = 10;
    const height = categories.length * (barHeight + gap) - gap;

    const svgEl = d3.select('#' + containerId)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    const svg = svgEl.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const rc = rough.svg(svgEl.node());

    const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);

    categories.forEach((cat, i) => {
        const y = i * (barHeight + gap);
        const prob = probs[cat];
        const barW = xScale(prob);

        // Bar
        if (barW > 2) {
            svg.node().appendChild(rc.rectangle(0, y, barW, barHeight, {
                fill: colors[cat], fillStyle: 'solid',
                stroke: colors[cat], strokeWidth: 0.5,
                roughness: 1.2, seed: seedBase + i
            }));
        }

        // Category label (left)
        svg.append('text').attr('class', 'tick-label')
            .attr('x', -8).attr('y', y + barHeight / 2 + 4)
            .attr('text-anchor', 'end')
            .style('font-size', '13px')
            .text(cat);

        // Percentage label (right of bar)
        svg.append('text').attr('class', 'tick-label')
            .attr('x', barW + 8).attr('y', y + barHeight / 2 + 4)
            .style('font-size', '13px').style('font-weight', '600')
            .text(Math.round(prob * 100) + '%');
    });
}

function drawTrendChart() {
    const categories = ['Large Increase', 'Increase', 'Stable', 'Decrease', 'Large Decrease'];
    const probs = { 'Large Increase': 0.08, 'Increase': 0.52, 'Stable': 0.28, 'Decrease': 0.09, 'Large Decrease': 0.03 };
    const colors = {
        'Large Increase': '#c0392b', 'Increase': '#E87D5F', 'Stable': '#999',
        'Decrease': '#5ACDC5', 'Large Decrease': '#344D84'
    };
    drawHorizontalBarChart('trend-chart', categories, probs, colors, 4000);
}

function drawActivityChart() {
    const categories = ['Very High', 'High', 'Medium', 'Low'];
    const probs = { 'Very High': 0.05, 'High': 0.35, 'Medium': 0.45, 'Low': 0.15 };
    const colors = {
        'Very High': '#c0392b', 'High': '#E87D5F', 'Medium': '#F2C45A', 'Low': '#5ACDC5'
    };
    drawHorizontalBarChart('activity-chart', categories, probs, colors, 4100);
}

// --- Charts: Gauge/Dial Visualizations ---
function drawGauge(containerId, categories, probs, colors, seedBase) {
    d3.select('#' + containerId).selectAll('*').remove();

    const container = document.getElementById(containerId);
    const totalW = Math.min(container.clientWidth, 360);
    const cx = totalW / 2;
    const cy = totalW * 0.48;
    const outerR = totalW * 0.38;
    const innerR = outerR * 0.55;
    const svgH = totalW * 0.62;

    const svgEl = d3.select('#' + containerId)
        .append('svg')
        .attr('width', totalW)
        .attr('height', svgH);

    const rc = rough.svg(svgEl.node());

    // Draw arc segments — from π (left) to 0 (right)
    let startAngle = Math.PI;
    const totalProb = categories.reduce((s, c) => s + probs[c], 0);

    // Find the most likely category for the needle
    let maxProb = 0, maxCat = categories[0];
    categories.forEach(c => { if (probs[c] > maxProb) { maxProb = probs[c]; maxCat = c; } });

    // Compute needle angle (weighted average)
    let needleAngle = 0;
    let cumAngle = Math.PI;
    const segAngles = [];
    categories.forEach(c => {
        const sweep = (probs[c] / totalProb) * Math.PI;
        const midAngle = cumAngle - sweep / 2;
        segAngles.push({ cat: c, start: cumAngle, end: cumAngle - sweep, mid: midAngle });
        needleAngle += probs[c] * midAngle;
        cumAngle -= sweep;
    });
    needleAngle /= totalProb;

    // Draw each arc segment
    segAngles.forEach((seg, i) => {
        const steps = 20;
        const sweepAngle = seg.start - seg.end;
        let pathD = '';

        // Outer arc
        for (let s = 0; s <= steps; s++) {
            const a = seg.start - (s / steps) * sweepAngle;
            const x = cx + outerR * Math.cos(a);
            const y = cy - outerR * Math.sin(a);
            pathD += (s === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1);
        }
        // Inner arc (reverse)
        for (let s = steps; s >= 0; s--) {
            const a = seg.start - (s / steps) * sweepAngle;
            const x = cx + innerR * Math.cos(a);
            const y = cy - innerR * Math.sin(a);
            pathD += 'L' + x.toFixed(1) + ',' + y.toFixed(1);
        }
        pathD += 'Z';

        svgEl.node().appendChild(rc.path(pathD, {
            fill: colors[seg.cat], fillStyle: 'solid',
            stroke: '#fff', strokeWidth: 2,
            roughness: 1.0, seed: seedBase + i
        }));

        // Category label on outer edge
        const labelR = outerR + 14;
        const labelAngle = seg.mid;
        const lx = cx + labelR * Math.cos(labelAngle);
        const ly = cy - labelR * Math.sin(labelAngle);
        const anchor = labelAngle > Math.PI / 2 ? 'end' : labelAngle < Math.PI / 2 ? 'start' : 'middle';
        svgEl.append('text')
            .attr('x', lx).attr('y', ly + 4)
            .attr('text-anchor', anchor)
            .style('font-family', "'Patrick Hand', cursive")
            .style('font-size', '11px')
            .style('fill', '#1C2442')
            .text(seg.cat);
    });

    // Draw needle
    const needleLen = outerR * 0.92;
    const nx = cx + needleLen * Math.cos(needleAngle);
    const ny = cy - needleLen * Math.sin(needleAngle);
    svgEl.node().appendChild(rc.line(cx, cy, nx, ny, {
        stroke: '#1C2442', strokeWidth: 2.5, roughness: 0.6, seed: seedBase + 50
    }));
    // Needle hub
    svgEl.node().appendChild(rc.circle(cx, cy, 12, {
        fill: '#1C2442', fillStyle: 'solid',
        stroke: '#1C2442', strokeWidth: 1,
        roughness: 0.8, seed: seedBase + 51
    }));

    // Text below: predicted category + probability
    svgEl.append('text')
        .attr('x', cx).attr('y', cy + 20)
        .attr('text-anchor', 'middle')
        .style('font-family', "'Montserrat', sans-serif")
        .style('font-size', '16px')
        .style('font-weight', '700')
        .style('fill', colors[maxCat])
        .text(maxCat);

    svgEl.append('text')
        .attr('x', cx).attr('y', cy + 38)
        .attr('text-anchor', 'middle')
        .style('font-family', "'Lato', sans-serif")
        .style('font-size', '13px')
        .style('fill', '#666')
        .text(Math.round(maxProb * 100) + '% probability');
}

function drawTrendGauge() {
    const categories = ['Large Decrease', 'Decrease', 'Stable', 'Increase', 'Large Increase'];
    const probs = { 'Large Increase': 0.08, 'Increase': 0.52, 'Stable': 0.28, 'Decrease': 0.09, 'Large Decrease': 0.03 };
    const colors = {
        'Large Increase': '#c0392b', 'Increase': '#E87D5F', 'Stable': '#999',
        'Decrease': '#5ACDC5', 'Large Decrease': '#344D84'
    };
    drawGauge('trend-gauge', categories, probs, colors, 5000);
}

function drawActivityGauge() {
    const categories = ['Low', 'Medium', 'High', 'Very High'];
    const probs = { 'Very High': 0.05, 'High': 0.35, 'Medium': 0.45, 'Low': 0.15 };
    const colors = {
        'Very High': '#c0392b', 'High': '#E87D5F', 'Medium': '#F2C45A', 'Low': '#5ACDC5'
    };
    drawGauge('activity-gauge', categories, probs, colors, 5100);
}

// --- Navigation & Controls ---
function setupNavigation() {
    const sidebar = document.getElementById('sidebar');
    const toggle = document.getElementById('sidebar-toggle');
    const mobileBtn = document.getElementById('mobile-menu-btn');

    // Sidebar toggle button
    toggle.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
        toggle.classList.toggle('closed');
        // Redraw current charts after layout shift
        setTimeout(redrawActiveSection, 250);
    });

    // Mobile hamburger
    mobileBtn.addEventListener('click', () => {
        sidebar.classList.toggle('open');
    });

    // Section switching — handle clicks on any element with data-section
    document.addEventListener('click', (e) => {
        const target = e.target.closest('[data-section]');
        if (!target || target.classList.contains('disabled')) return;

        const sectionId = target.dataset.section;
        const sectionEl = document.getElementById(sectionId);
        if (!sectionEl) return;

        // Switch content panels
        document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
        sectionEl.classList.add('active');

        // Update nav active state
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        document.querySelectorAll(`.nav-item[data-section="${sectionId}"]`).forEach(n => n.classList.add('active'));

        // Close sidebar on mobile after selection
        if (window.innerWidth <= 600) {
            sidebar.classList.remove('open');
        }

        // Redraw charts for the activated section
        setTimeout(() => redrawActiveSection(sectionId), 50);
    });
}

function redrawActiveSection(sectionId) {
    if (!sectionId) {
        const active = document.querySelector('.content-section.active');
        sectionId = active ? active.id : null;
    }
    if (sectionId === 'section-pi') {
        const piEnabled = Array.from(document.querySelectorAll('.toggle-btn.active[data-interval]'))
            .map(b => parseInt(b.dataset.interval));
        drawChart(piEnabled);
    } else if (sectionId === 'section-trends') {
        drawTrendGauge();
        drawActivityGauge();
        drawTrendChart();
        drawActivityChart();
    } else if (sectionId === 'section-wis') {
        const wisEnabled = Array.from(document.querySelectorAll('.toggle-btn.active[data-wis-box-interval]'))
            .map(b => parseInt(b.dataset.wisBoxInterval));
        drawBoxChart(wisEnabled);
        redrawBoxplot();
        drawRWISChart();
    }
}

// --- Init ---
loadData();
    </script>
</body>
</html>
